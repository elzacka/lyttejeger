/**
 * Custom Service Worker with Periodic Background Sync
 * Extends the default Workbox service worker generated by vite-plugin-pwa
 */

declare const self: ServiceWorkerGlobalScope;

// Periodic Background Sync - update subscribed podcasts
self.addEventListener('periodicsync', (event: any) => {
  if (event.tag === 'update-subscriptions') {
    event.waitUntil(updateSubscriptions());
  }
});

async function updateSubscriptions() {
  try {
    // Get subscribed podcast IDs from IndexedDB
    const db = await openDatabase();
    const subscriptions = await getSubscriptions(db);

    if (subscriptions.length === 0) {
      return;
    }

    // Fetch latest episodes for each subscribed podcast
    const updatePromises = subscriptions.map(async (podcastId: string) => {
      try {
        const response = await fetch(
          `https://api.podcastindex.org/api/1.0/episodes/bypodcastid?id=${podcastId}&max=5`,
          {
            headers: {
              'User-Agent': 'Lyttejeger/1.0',
            },
          }
        );

        if (response.ok) {
          const data = await response.json();
          // Cache the updated episodes
          const cache = await caches.open('podcast-api-cache');
          await cache.put(response.url, response.clone());
        }
      } catch (err) {
        console.error(`Failed to update podcast ${podcastId}:`, err);
      }
    });

    await Promise.allSettled(updatePromises);

    // Show notification if new episodes found
    const newEpisodesCount = await getNewEpisodesCount(db);
    if (newEpisodesCount > 0) {
      await self.registration.showNotification('Lyttejeger', {
        body: `${newEpisodesCount} nye episoder tilgjengelig`,
        icon: '/lyttejeger/icon-192x192.png',
        badge: '/lyttejeger/favicon.svg',
        tag: 'new-episodes',
        renotify: false,
      });
    }
  } catch (error) {
    console.error('Failed to update subscriptions:', error);
  }
}

// IndexedDB helpers
function openDatabase(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('lyttejeger-db', 1);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);

    request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
      const db = (event.target as IDBOpenDBRequest).result;
      if (!db.objectStoreNames.contains('subscriptions')) {
        db.createObjectStore('subscriptions', { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains('episodes')) {
        db.createObjectStore('episodes', { keyPath: 'id' });
      }
    };
  });
}

function getSubscriptions(db: IDBDatabase): Promise<string[]> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(['subscriptions'], 'readonly');
    const store = transaction.objectStore('subscriptions');
    const request = store.getAllKeys();

    request.onsuccess = () => resolve(request.result as string[]);
    request.onerror = () => reject(request.error);
  });
}

async function getNewEpisodesCount(db: IDBDatabase): Promise<number> {
  // Simple implementation - count episodes added in last sync
  // In a real app, you'd track which episodes are "new" since last check
  return 0; // Placeholder
}

// Handle Share Target API
self.addEventListener('fetch', (event: FetchEvent) => {
  const url = new URL(event.request.url);

  // Handle share target
  if (url.pathname === '/lyttejeger/share' && event.request.method === 'GET') {
    const sharedUrl = url.searchParams.get('url');
    const sharedText = url.searchParams.get('text');
    const sharedTitle = url.searchParams.get('title');

    // Redirect to main app with shared data
    const targetUrl = new URL('/lyttejeger/', self.location.origin);
    if (sharedUrl) targetUrl.searchParams.set('shared_url', sharedUrl);
    if (sharedText) targetUrl.searchParams.set('shared_text', sharedText);
    if (sharedTitle) targetUrl.searchParams.set('shared_title', sharedTitle);

    event.respondWith(Response.redirect(targetUrl.toString(), 303));
    return;
  }
});

// Export for TypeScript
export {};
